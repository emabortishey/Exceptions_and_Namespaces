#include "DoublyLinkedList.h"
#include "Exception.h"

void DoublyLinkedList::append(int value) 
{
    if (typeid(value).name() != "int")
    {
        throw WrongTydeid("\n\nValue isn't having the same type id as a Node::data! Value couln't be added into the list.\n\n");
    }
    // создание динамической переменной заполняемой
    // значением которое добавится в конец списка
    Node* newNode = new Node(value);

    if (tail == nullptr)
    {   // если список пуст, элемент добавляется
        // как первый и последний, то есть записывается
        // в оба атрибута, тейл и хед
        head = tail = newNode;
    }
    else
    {
        // если же в списке есть элементы то
        // созданная переменная сначала записывается
        // в атрибут некст переменной под указателем хвоста
        // далее новой переменной в атрибут прев присваивается хвост,
        // а после атрибуту хвоста присваиваеся указатель на
        // эту новую переменную
        tail->next = newNode;
        newNode->prev = tail;
        tail = newNode;
    }
}

void DoublyLinkedList::removeLast()
{
    if (head == nullptr)
    {   // если список пуст, удаление последнего элемента невозможно
        // поэтому происходит выброс исключения
        throw ContainerIsEmpty("\nIt's impossible to remove the last element, container is already empty.\n");

        return;
    }
    else if (head == tail)
    {   // если в списке 1 элемент, его динамическая память
        // очищается делитом и атрибутам-указателям присваивается нуллптр
        delete head;
        head = tail = nullptr;
    }
    else
    {
        // создается указатель-буффер на последний элемент
        Node* temp = tail;

        // атрибуту указателя на хвост присваивается предыдущий элемент
        tail = tail->prev;

        // следующему элементу нового хвоста присваивается
        // нуллптр (происходит обнуление)
        tail->next = nullptr;

        // очищение динамической памяти с помощью указателя на
        // бывший хвостовой элемент
        delete temp;
    }
}

// Печать списка
void DoublyLinkedList::print() const noexcept
{
    // буферный элемент для пробежки по элементам
    Node* current = head;

    // пока не будет достигнут конец, цикл продолжается 
    while (current != nullptr)
    {
        // вывод атрибута со значением из текущего элемента
        cout << current->data << " ";

        // переход к следующему элементу
        current = current->next;
    }
}

bool DoublyLinkedList::search(int value) const noexcept
{
    // элемент для пробега по элементам
    Node* current = head;

    while (current != nullptr)
    {
        // сравнение с переданным значенеим текущего элемента
        if (current->data == value)
        {
            // возвращение тру если условие выполнено
            return true;
        }

        // переход к следующему элементу
        current = current->next;
    }

    // если условие так и не было выполнено, возвращаем фолс
    return false;
}

DoublyLinkedList::~DoublyLinkedList()
{
    // буфер
    Node* current = head;

    // пока последний элемент не будет достигнут
    while (current != nullptr)
    {
        // сохраняем текущее значение в ещё 1 буфер, т.к. при удалении
        // мы не сможем перейти к след. элементу
        Node* nextNode = current->next;

        // удаляем текущий элемент
        delete current;

        // присваиваем 1 буферу значение недавно созданного 2
        current = nextNode;
    }
}